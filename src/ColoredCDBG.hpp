#ifndef BFG_COLOREDCDBG_HPP
#define BFG_COLOREDCDBG_HPP

#include <iostream>
#include <random>

#include "ColorSet.hpp"

#define BFG_COLOREDCDBG_FORMAT_VERSION 1

/** @file src/ColoredCDBG.hpp
* Interface for the Colored and Compacted de Bruijn graph API.
* Code snippets using this interface are provided in snippets.hpp.
*/

/** @struct CCDBG_Build_opt
* @brief Members of this structure are parameters for ColoredCDBG::build, except for:
* - CCDBG_Build_opt::k and CCDBG_Build_opt::g as they must be set in the constructor of the graph.
* - CCDBG_Build_opt::clipTips, CCDBG_Build_opt::deleteIsolated and CCDBG_Build_opt::useMercyKmers are used
* by ColoredCDBG::simplify
* - CCDBG_Build_opt::prefixFilenameOut, CCDBG_Build_opt::outputGFA and CCDBG_Build_opt::outputColors are
* used by ColoredCDBG::write
* Most parameters have default values.
* An example of using such a structure is shown in src/Bifrost.cpp.
* @var CCDBG_Build_opt::reference_mode
* Input are assembled genomes, unitigs or graph files (true), no filtering step performed, all k-mers are used.
* You must not directly build a ColoredCDBG from reads (check README file).
* Default is true.
* @var CCDBG_Build_opt::verbose
* Print information messages during execution if true. Default is false.
* @var CCDBG_Build_opt::clipTips
* Clip short (length < 2k) tips of the graph (not used by ColoredCDBG::build). Default is false.
* @var CCDBG_Build_opt::deleteIsolated
* Remove short (length < 2k) isolated unitigs of the graph (not used by ColoredCDBG::build).
* Default is false.
* @var CCDBG_Build_opt::useMercyKmers
* Keep in the graph low coverage k-mers connecting tips of the graph. Default is false.
* @var CCDBG_Build_opt::k
* Length of k-mers (not used by ColoredCDBG::build). Default is 31.
* @var CCDBG_Build_opt::g
* Length of g-mers, the minimizers, such that g < k (not used by ColoredCDBG::build).
* Default is 23.
* @var CCDBG_Build_opt::nb_threads
* Number of threads to use for building the graph. Default is 1.
* @var CCDBG_Build_opt::read_chunksize
* Number of reads shared and processed by CCDBG_Build_opt::nb_threads threads at the same time.
* Default is 10000.
* @var CCDBG_Build_opt::unitig_size
* Maximum length of a unitig. Default is 100000.
* @var CCDBG_Build_opt::nb_unique_kmers
* Estimated number (upper bound) of different k-mers in the input FASTA/FASTQ/GFA files of
* CCDBG_Build_opt::filename_in. Default is KmerStream estimation.
* @var CCDBG_Build_opt::nb_non_unique_kmers
* Estimated number (upper bound) of different k-mers occurring twice or more in the FASTA/FASTQ/GFA files
* of CCDBG_Build_opt::filename_in. Default is KmerStream estimation.
* @var CCDBG_Build_opt::nb_bits_unique_kmers_bf
* Number of Bloom filter bits per k-mer occurring at least once in the FASTA/FASTQ/GFA files of
* CCDBG_Build_opt::filename_in. Default is 14.
* @var CCDBG_Build_opt::nb_bits_non_unique_kmers_bf
* Number of Bloom filter bits per k-mer occurring at least twice in the FASTA/FASTQ/GFA files of
* CCDBG_Build_opt::filename_in. Default is 14.
* @var CCDBG_Build_opt::prefixFilenameOut
* Prefix for the name of the file to which the graph must be written (not used by ColoredCDBG::build).
* (not used by ColoredCDBG::build). Mandatory parameter.
* @var CCDBG_Build_opt::inFilenameBBF
* String containing the name of a Bloom filter file that is generated by ColoredCDBG::filter.
* If empty, the filtering step is executed. Otherwise, the Bloom filter is loaded from this file
* and the filtering step is skipped. Default is no input file.
* @var CCDBG_Build_opt::outFilenameBBF
* String containing the name of a Bloom filter file that will be generated by ColoredCDBG::filter.
* If empty, the file is not created. Otherwise, the Bloom filter is written to this file.
* Default is no output file.
* @var CCDBG_Build_opt::filename_seq_in
* vector of strings, each string is the name of a FASTA/FASTQ/GFA file to use for the graph construction.
* Mandatory parameter.
* @var CCDBG_Build_opt::filename_colors_in
* vector of strings, each string is the name of a color set file to use for the graph construction.
* If not empty, colors are loaded in memory from the files. In such case, the color filenames order
* in this vector must match the order of the filenames in CCDBG_Build_opt::filename_seq_in.
* Default is no input color files.
* @var CCDBG_Build_opt::outputGFA
* Boolean indicating if the graph is written to a GFA file (true) or if the unitigs are written to a
* FASTA file (false). Default is true.
* @var CCDBG_Build_opt::outputColors
* Boolean indicating if color sets must be written to disk (true) or not (false). Default is true.
*/
struct CCDBG_Build_opt {

    bool reference_mode;
    bool verbose;

    size_t nb_threads;
    size_t read_chunksize;
    size_t unitig_size;
    size_t nb_unique_kmers;
    size_t nb_non_unique_kmers;
    size_t nb_bits_unique_kmers_bf;
    size_t nb_bits_non_unique_kmers_bf;

    string inFilenameBBF;
    string outFilenameBBF;

    vector<string> filename_seq_in;

    // The following members are not used by CompactedDBG<T>::build
    // but you can set them to use them as parameters for other functions
    // such as CompactedDBG<T>::simplify or CompactedDBG<T>::write.

    vector<string> filename_colors_in;

    size_t k, g;

    bool clipTips;
    bool deleteIsolated;
    bool useMercyKmers;

    bool outputGFA;
    bool outputColors;

    string prefixFilenameOut;

    CCDBG_Build_opt() : nb_threads(1), k(DEFAULT_K), g(DEFAULT_G), nb_unique_kmers(0), nb_non_unique_kmers(0),
                        nb_bits_unique_kmers_bf(14), nb_bits_non_unique_kmers_bf(14), read_chunksize(10000),
                        unitig_size(1000000), verbose(false), clipTips(false), deleteIsolated(false), useMercyKmers(false),
                        outputGFA(true), outputColors(true), reference_mode(true), inFilenameBBF(""), outFilenameBBF("") {}

    /** Creates a CDBG_Build_opt for CompactedDBG from a CCDBG_Build_opt.
    * @return a CDBG_Build_opt
    */
    CDBG_Build_opt getCDBG_Build_opt() const {

        CDBG_Build_opt cdbg_opt;

        cdbg_opt.reference_mode = reference_mode;
        cdbg_opt.filename_in = filename_seq_in;

        cdbg_opt.verbose = verbose;

        cdbg_opt.nb_threads = nb_threads;
        cdbg_opt.read_chunksize = read_chunksize;
        cdbg_opt.unitig_size = unitig_size;
        cdbg_opt.nb_unique_kmers = nb_unique_kmers;
        cdbg_opt.nb_non_unique_kmers = nb_non_unique_kmers;
        cdbg_opt.nb_bits_unique_kmers_bf = nb_bits_unique_kmers_bf;
        cdbg_opt.nb_bits_non_unique_kmers_bf = nb_bits_non_unique_kmers_bf;

        cdbg_opt.inFilenameBBF = inFilenameBBF;
        cdbg_opt.outFilenameBBF = outFilenameBBF;

        cdbg_opt.clipTips = clipTips;
        cdbg_opt.deleteIsolated = deleteIsolated;
        cdbg_opt.useMercyKmers = useMercyKmers;

        cdbg_opt.outputGFA = outputGFA;

        cdbg_opt.prefixFilenameOut = prefixFilenameOut;

        return cdbg_opt;
    }
};

class ColoredCDBG : public CompactedDBG<HashID> {

    friend class HashID;

    public:

        ColoredCDBG(int kmer_length = DEFAULT_K, int minimizer_length = DEFAULT_G);
        ColoredCDBG(const ColoredCDBG& o); // Copy constructor
        ColoredCDBG(ColoredCDBG&& o); // Move constructor

        ~ColoredCDBG();

        ColoredCDBG& operator=(const ColoredCDBG& o); // Copy assignment
        ColoredCDBG& operator=(ColoredCDBG&& o); // Move assignment

        void clear();
        void empty();

        bool build(const CCDBG_Build_opt& opt);

        bool mapColors(const CCDBG_Build_opt& opt);

        bool setColor(const UnitigMap<HashID>& um, size_t color);
        bool joinColors(const UnitigMap<HashID>& um_dest, const UnitigMap<HashID>& um_src);

        const ColorSet* getColorSet(const UnitigMap<HashID>& um) const; // Can be used to query a color set

        vector<string> extractColorNames(const UnitigMap<HashID>& um) const; // Return union of color names matching the UnitigMap
        ColorSet extractColors(const UnitigMap<HashID>& um) const; // Return new color set matching the UnitigMap

        bool write(const string output_filename, const size_t nb_threads, const bool verbose);

    private:

        void initColorSets(const CCDBG_Build_opt& opt, const size_t max_nb_hash = 31);
        void buildColorSets(const size_t nb_threads);
        bool readColorSets(const CCDBG_Build_opt& opt);

        ColorSet* getColorSet(const UnitigMap<HashID>& um);

        void checkColors(const CCDBG_Build_opt& opt);

        uint64_t getHash(const UnitigMap<HashID>& um) const;

        uint64_t seeds[256];

        bool invalid;

        size_t nb_seeds;
        size_t nb_color_sets;

        ColorSet* color_sets;

        KmerHashTable<ColorSet> km_overflow;

        vector<string> color_names;
};

#endif
