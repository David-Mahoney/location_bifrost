#ifndef COMPACTED_DBG_HPP
#define COMPACTED_DBG_HPP

#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cstdio>
#include <functional>
#include <getopt.h>
#include <iostream>
#include <sstream>
#include <stdint.h>
#include <string>
#include <sys/stat.h>
#include <vector>

#include <thread>
#include <atomic>
#include <mutex>

//#include <jemalloc/jemalloc.h>

#include "BlockedBloomFilter.hpp"
#include "Common.hpp"
#include "File_Parser.hpp"
#include "FASTX_Parser.hpp"
#include "GFA_Parser.hpp"
#include "Kmer.hpp"
#include "KmerHashTable.hpp"
#include "KmerIterator.hpp"
#include "KmerStream.hpp"
#include "minHashIterator.hpp"
#include "RepHash.hpp"
#include "TinyVector.hpp"
#include "Unitig.hpp"
#include "UnitigIterator.hpp"
#include "UnitigMap.hpp"

#define MASK_CONTIG_ID (0xffffffff00000000)
#define MASK_CONTIG_TYPE (0x80000000)
#define MASK_CONTIG_POS (0x7fffffff)
#define RESERVED_ID (0xffffffff)

#define DEFAULT_K 31
#define DEFAULT_G 23

/** @file src/CompactedDBG.hpp
* Interface for the Compacted de Bruijn graph API.
* Code snippets using this interface are provided in snippets.hpp.
*/

using namespace std;

/** @struct CDBG_Build_opt
* @brief Members of this structure are parameters for CompactedDBG<T>::build, except for:
* - CDBG_Build_opt::k and CDBG_Build_opt::g as they must be set in the constructor of the graph.
* - CDBG_Build_opt::clipTips, CDBG_Build_opt::deleteIsolated and CDBG_Build_opt::useMercyKmers are used
* by CompactedDBG<T>::simplify
* - CDBG_Build_opt::prefixFilenameOut and CDBG_Build_opt::outputGFA are used by CompactedDBG<T>::write
* Most parameters have default values.
* An example of using such a structure is shown in src/Bifrost.cpp.
* @var CDBG_Build_opt::reference_mode
* Input are assembled genomes or graph files (true), no filtering step performed, all k-mers are used.
* Otherwise, input are reads (false), filtering step is performed, k-mers with coverage < 2 are removed.
* Default is false.
* @var CDBG_Build_opt::verbose
* Print information messages during execution if true. Default is false.
* @var CDBG_Build_opt::clipTips
* Clip short (length < 2k) tips of the graph (not used by CompactedDBG<T>::build). Default is false.
* @var CDBG_Build_opt::deleteIsolated
* Remove short (length < 2k) isolated unitigs of the graph (not used by CompactedDBG<T>::build).
* Default is false.
* @var CDBG_Build_opt::useMercyKmers
* Keep in the graph low coverage k-mers connecting tips of the graph. Default is false.
* @var CDBG_Build_opt::k
* Length of k-mers (not used by CompactedDBG<T>::build). Default is 31.
* @var CDBG_Build_opt::g
* Length of g-mers, the minimizers, such that g < k (not used by CompactedDBG<T>::build).
* Default is 23.
* @var CDBG_Build_opt::nb_threads
* Number of threads to use for building the graph. Default is 1.
* @var CDBG_Build_opt::read_chunksize
* Number of reads shared and processed by CDBG_Build_opt::nb_threads threads at the same time.
* Default is 10000.
* @var CDBG_Build_opt::unitig_size
* Maximum length of a unitig. Default is 100000.
* @var CDBG_Build_opt::nb_unique_kmers
* Estimated number (upper bound) of different k-mers in the input FASTA/FASTQ/GFA files of
* CDBG_Build_opt::filename_in. Default is KmerStream estimation.
* @var CDBG_Build_opt::nb_non_unique_kmers
* Estimated number (upper bound) of different k-mers occurring twice or more in the FASTA/FASTQ/GFA files
* of CDBG_Build_opt::filename_in. Default is KmerStream estimation.
* @var CDBG_Build_opt::nb_bits_unique_kmers_bf
* Number of Bloom filter bits per k-mer occurring at least once in the FASTA/FASTQ/GFA files of
* CDBG_Build_opt::filename_in. Default is 14.
* @var CDBG_Build_opt::nb_bits_non_unique_kmers_bf
* Number of Bloom filter bits per k-mer occurring at least twice in the FASTA/FASTQ/GFA files of
* CDBG_Build_opt::filename_in. Default is 14.
* @var CDBG_Build_opt::prefixFilenameOut
* Prefix for the name of the file to which the graph must be written. Mandatory parameter.
* @var CDBG_Build_opt::inFilenameBBF
* String containing the name of a Bloom filter file that is generated by CompactedDBG<T>::filter.
* If empty, the filtering step is executed. Otherwise, the Bloom filter is loaded from this file
* and the filtering step is skipped. Default is no input file.
* @var CDBG_Build_opt::outFilenameBBF
* String containing the name of a Bloom filter file that will be generated by CompactedDBG<T>::filter.
* If empty, the file is not created. Otherwise, the Bloom filter is written to this file.
* Default is no output file.
* @var CDBG_Build_opt::filename_in
* vector of strings, each string is the name of a FASTA/FASTQ/GFA file to use for the graph construction.
* Mandatory parameter.
* @var CDBG_Build_opt::outputGFA
* Boolean indicating if the graph is written to a GFA file (true) or if the unitigs are written to a
* FASTA file (false). Default is true.
*/
struct CDBG_Build_opt {

    bool reference_mode;
    bool verbose;

    size_t nb_threads;
    size_t read_chunksize;
    size_t unitig_size;
    size_t nb_unique_kmers;
    size_t nb_non_unique_kmers;
    size_t nb_bits_unique_kmers_bf;
    size_t nb_bits_non_unique_kmers_bf;

    string inFilenameBBF;
    string outFilenameBBF;

    vector<string> filename_in;

    // The following members are not used by CompactedDBG<T>::build
    // but you can set them to use them as parameters for other functions
    // such as CompactedDBG<T>::simplify or CompactedDBG<T>::write.

    size_t k, g;

    bool clipTips;
    bool deleteIsolated;
    bool useMercyKmers;

    bool outputGFA;

    string prefixFilenameOut;

    CDBG_Build_opt() :  nb_threads(1), k(DEFAULT_K), g(DEFAULT_G), nb_unique_kmers(0), nb_non_unique_kmers(0), nb_bits_unique_kmers_bf(14),
                        nb_bits_non_unique_kmers_bf(14), read_chunksize(10000), unitig_size(1000000), reference_mode(false),
                        verbose(false), clipTips(false), deleteIsolated(false), useMercyKmers(false), outputGFA(true), inFilenameBBF(""),
                        outFilenameBBF("") {}
};

/** @class CDBG_Data_t
* @brief If data are to be associated with the unitigs of the compacted de Bruijn graph, these data
* must be wrapped into a class that inherits from the abstract class CDBG_Data_t. Otherwise it
* will not compile. Hence, to associate data of type myData to unitigs, class myData must be declared as follows:
* \code{.cpp}
* class myData : public CDBG_Data_t<myData> { ... };
* \endcode
* Because CDBG_Data_t is an abstract class and its functions are virtual, CDBG_Data_t<T>::join and CDBG_Data_t<T>::split
* must be implemented in your wrapper. An example of using such a structure is shown in src/snippets.cpp.
*/
template<typename T> //Curiously Recurring Template Pattern (CRTP)
class CDBG_Data_t {

    public:

        /** Join data of two unitigs (each represented with a UnitigMap given as parameter) which are going to be concatenated.
        * Specifically, if A is the unitig represented by parameter um_dest and B is the unitig represented by parameter um_src
        * then, after the call to this function, A will be the concatenation of itself with B (A = AB) and B will be removed.
        * Be careful that if um_dest.strand = false, then the reverse-complement of A is going to be used in the concatenation.
        * Reciprocally, if um_src.strand = false, then the reverse-complement of B is going to be used in the concatenation.
        * The data of each unitig can be accessed and modified through the methods UnitigMap::getData() and UnitigMap::setData().
        * Usually, after joining the data, you want to use um_dest.setData() such that the new data are associated with unitig A.
        * @param um_dest is a UnitigMap object representing a unitig (and its data) to which another unitig is going to be appended.
        * @param um_src is a UnitigMap object representing a unitig (and its data) that will be appended at the end of the unitig
        * represented by parameter um_dest.
        */
        virtual void join(const UnitigMap<T>& um_dest, const UnitigMap<T>& um_src) = 0;

        /** Extract data from a unitig A (represented by the UnitigMap object um_src given in parameter) to be associated with a
        * sub-unitig B such that B = A[um_src.dist, um_src.dist + um_src.len]. Be careful that if um_src.strand = false, then B
        * will be extracted from the reverse-complement of A.
        * @param um_src is a UnitigMap object representing a unitig A (and its data) from which a new sub-unitig B will be extracted.
        * um_src.dist corresponds to the start position of sub-unitig B into A, um_src.len corresponds to the length of sub-unitig B.
        * @param new_data is an new (empty) object that you can fill in with the new data of B.
        * @param last_extraction is a boolean indicating if this is the last call to this function on the unitig represented by um_src.
        * If last_extraction is true, the unitig represented by um_src will be removed from the graph right after the call to sub().
        */
        virtual void sub(const UnitigMap<T>& um_src, T& new_data, bool last_extraction) const = 0;

        /** Serialize the data to a string. This function is used when the graph is written to disk in GFA format.
        * If the returned string is not empty, the string is appended to an optional field of the Segment line matching the unitig
        * of this data. If the returned string is empty, no optional field and string are appended to the Segment line matching the
        * unitig of this data.
        */
        virtual string serialize() const = 0;
};

/** @class CompactedDBG
* @brief Represent a Compacted de Bruijn graph. The template parameter of this class corresponds to the type of data
* to associate with the unitigs of the graph. If no template parameter is specified or if the type is void, such as in
* \code{.cpp}
* CompactedDBG<> cdbg_1;
* CompactedDBG<void> cdbg_2; //Equivalent to previous notation
* \endcode
* then, no data are associated with the unitigs and no memory will be allocated for it. If data are to be associated
* with the unitigs, these data must be wrapped into a class that inherits from the abstract class CDBG_Data_t, such as in:
* \code{.cpp}
* class myData : public CDBG_Data_t<myData> { ... };
* CompactedDBG<myData> cdbg;
* \endcode
*/
template<typename T = void>
class CompactedDBG {

    static_assert(is_void<T>::value || is_base_of<CDBG_Data_t<T>, T>::value,
                  "Type of data associated with vertices of class CompactedDBG must be void (no data) or a class extending class CDBG_Data_t");

    private:

        int k_;
        int g_;

        bool invalid;

        bool has_data;

        static const int tiny_vector_sz = 2;
        static const int min_abundance_lim = 15;
        static const int max_abundance_lim = 15;

        typedef KmerHashTable<CompressedCoverage_t<T>> h_kmers_ccov_t;
        typedef MinimizerHashTable_2Val hmap_min_unitigs_t;

        typedef typename hmap_min_unitigs_t::iterator hmap_min_unitigs_iterator;
        typedef typename hmap_min_unitigs_t::const_iterator hmap_min_unitigs_const_iterator;

        vector<Unitig<T>*> v_unitigs;
        vector<pair<Kmer, CompressedCoverage_t<T>>> v_kmers;

        hmap_min_unitigs_t hmap_min_unitigs;

        h_kmers_ccov_t h_kmers_ccov;

        BlockedBloomFilter bf;

    public:

        typedef T U;

        template<typename U> friend class UnitigMap;
        template<typename U, bool is_const> friend class unitigIterator;
        template<typename U, bool is_const> friend class neighborIterator;

        typedef unitigIterator<T, false> iterator; /**< An iterator for the unitigs of the graph. No specific order is assumed. */
        typedef unitigIterator<T, true> const_iterator; /**< A constant iterator for the unitigs of the graph. No specific order is assumed. */

        CompactedDBG(int kmer_length = DEFAULT_K, int minimizer_length = DEFAULT_G); // Constructor
        CompactedDBG(const CompactedDBG& cdbg); // Copy constructor
        CompactedDBG(CompactedDBG&& cdbg); // Move constructor

        virtual ~CompactedDBG();

        CompactedDBG<T>& operator=(const CompactedDBG& o); // Copy assignment operator
        CompactedDBG<T>& operator=(CompactedDBG&& o); //Move assignment operator

        void clear();
        void empty();

        /** Return a boolean indicating if the graph is invalid (wrong input parameters/files, problem during an operation, etc.).
        * @return A boolean indicating if the graph is invalid.
        */
        inline int isInvalid() const { return invalid; }

        /** Return the length of k-mers of the graph.
        * @return Length of k-mers of the graph.
        */
        inline int getK() const { return k_; }

        /** Return the number of unitigs in the graph.
        * @return Number of unitigs in the graph.
        */
        inline size_t size() const { return v_unitigs.size() + v_kmers.size() + h_kmers_ccov.size(); }

        bool build(CDBG_Build_opt& opt);
        bool simplify(const bool delete_short_isolated_unitigs = true, const bool clip_short_tips = true, const bool verbose = false);
        bool write(const string output_filename, const size_t nb_threads = 1, const bool GFA_output = true, const bool verbose = false);

        UnitigMap<T> find(const Kmer& km, const bool extremities_only = false);

        bool add(const string& seq, const bool verbose = false);
        bool remove(const UnitigMap<T>& um, const bool verbose = false);

        iterator begin();
        const_iterator begin() const;

        iterator end();
        const_iterator end() const;

    private:

        bool join(const UnitigMap<T>& um, const bool verbose);
        bool join(const bool verbose);

        bool filter(const CDBG_Build_opt& opt);
        bool construct(const CDBG_Build_opt& opt);

        bool addUnitigSequenceBBF(Kmer km, const string& seq, const size_t pos_match_km, const size_t len_match_km,
                                  std::atomic_flag* locks_unitig, const size_t thread_id, const size_t nb_threads);
        //bool addUnitigSequenceBBF(Kmer km, const string& seq, const size_t pos_match_km, const size_t len_match_km);
        size_t findUnitigSequenceBBF(Kmer km, string& s, bool& isIsolated, vector<Kmer>& l_ignored_km_tip);
        bool bwStepBBF(Kmer km, Kmer& front, char& c, bool& has_no_neighbor, vector<Kmer>& l_ignored_km_tip, bool check_fp_cand = true) const;
        bool fwStepBBF(Kmer km, Kmer& end, char& c, bool& has_no_neighbor, vector<Kmer>& l_ignored_km_tip, bool check_fp_cand = true) const;

        UnitigMap<T> findUnitig(const Kmer& km, const string& s, size_t pos);
        UnitigMap<T> findUnitig(const Kmer& km, const string& s, size_t pos, const preAllocMinHashIterator<RepHash>& it_min_h);

        bool addUnitig(const string& str_unitig, const size_t id_unitig);
        void deleteUnitig(const bool isShort, const bool isAbundant, const size_t id_unitig);
        void swapUnitigs(const bool isShort, const size_t id_a, const size_t id_b);
        bool splitUnitig(size_t& pos_v_unitigs, size_t& nxt_pos_insert_v_unitigs, size_t& v_unitigs_sz, size_t& v_kmers_sz,
                        const vector<pair<int,int>>& sp);

        UnitigMap<T> find(const Kmer& km, const preAllocMinHashIterator<RepHash>& it_min_h);
        vector<UnitigMap<T>> findPredecessors(const Kmer& km, const bool extremities_only = false);
        vector<UnitigMap<T>> findSuccessors(const Kmer& km, const size_t limit = 4, const bool extremities_only = false);

        inline size_t find(const preAllocMinHashIterator<RepHash>& it_min_h) const {

            const int pos = it_min_h.getPosition();
            return (hmap_min_unitigs.find(Minimizer(&it_min_h.s[pos]).rep()) != hmap_min_unitigs.end() ? 0 : pos - it_min_h.p);
        }

        pair<size_t, size_t> splitAllUnitigs();
        size_t joinUnitigs(vector<Kmer>* v_joins = nullptr, const size_t nb_threads = 1);

        bool checkJoin(const Kmer& a, const UnitigMap<T>& cm_a, Kmer& b);
        void check_fp_tips(KmerHashTable<bool>& ignored_km_tips);
        size_t removeUnitigs(bool rmIsolated, bool clipTips, vector<Kmer>& v);

        size_t joinTips(string filename_MBBF_uniq_kmers, const size_t nb_threads = 1, const bool verbose = false);
        vector<Kmer> extractMercyKmers(BlockedBloomFilter& bf_uniq_km, const size_t nb_threads = 1, const bool verbose = false);

        void writeGFA(string graphfilename, const size_t nb_threads = 1);
        void writeGFA_sequence(GFA_Parser& graph, KmerHashTable<size_t>& idmap);
        void writeFASTA(string graphfilename);

        void mapRead(const UnitigMap<T>& cc);

        void print() const;
};

#include "CompactedDBG.tcc"

#endif
